\documentclass{article}
\usepackage{amsmath,amsfonts,amsthm,amssymb}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{extramarks}
\usepackage{chngpage}
\usepackage{soul,color}
\usepackage{graphicx,float,wrapfig}
\usepackage{clrscode}
\usepackage{mathrsfs}
\newcommand{\Class}{CSE 202}
% \newcommand{\ClassInstructor}{Russell Impagliazzo}

% Homework Specific Information. Change it to your own
\newcommand{\Title}{Final Exam}
\newcommand{\StudentName}{Sai Bi}
\newcommand{\StudentClass}{}
\newcommand{\StudentNumber}{}

% In case you need to adjust margins:
\topmargin=-0.45in      %
\evensidemargin=0in     %
\oddsidemargin=0in      %
\textwidth=6.5in        %
\textheight=9.0in       %
\headsep=0.25in         %

% Setup the header and footer
\pagestyle{fancy}                                                       %
\lhead{\Title}  %
\rhead{\firstxmark}                                                     %
\lfoot{\lastxmark}                                                      %
\cfoot{}                                                                %
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}}                          %
\renewcommand\headrulewidth{0.4pt}                                      %
\renewcommand\footrulewidth{0.4pt}                                      %

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Some tools
\newcommand{\enterProblemHeader}[1]{\nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak%
    \nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak}%
\newcommand{\exitProblemHeader}[1]{\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak%
    \nobreak\extramarks{#1}{}\nobreak}%

\providecommand{\myceil}[1]{\left \lceil #1 \right \rceil }
\newcommand{\homeworkProblemName}{}%
\newcounter{homeworkProblemCounter}%
\newenvironment{homeworkProblem}[1][Problem \arabic{homeworkProblemCounter}]%
{\stepcounter{homeworkProblemCounter}%
    \renewcommand{\homeworkProblemName}{#1}%
    \section*{\homeworkProblemName}%
    \enterProblemHeader{\homeworkProblemName}}%
{\exitProblemHeader{\homeworkProblemName}}%

\newcommand{\homeworkSectionName}{}%
\newlength{\homeworkSectionLabelLength}{}%
\newenvironment{homeworkSection}[1]%
{% We put this space here to make sure we're not connected to the above.
    
    \renewcommand{\homeworkSectionName}{#1}%
    \settowidth{\homeworkSectionLabelLength}{\homeworkSectionName}%
    \addtolength{\homeworkSectionLabelLength}{0.25in}%
    \changetext{}{-\homeworkSectionLabelLength}{}{}{}%
    \subsection*{\homeworkSectionName}%
    \enterProblemHeader{\homeworkProblemName\ [\homeworkSectionName]}}%
{\enterProblemHeader{\homeworkProblemName}%
    
    % We put the blank space above in order to make sure this margin
    % change doesn't happen too soon.
    \changetext{}{+\homeworkSectionLabelLength}{}{}{}}%

\newcommand{\Answer}{\ \\\textbf{Answer:} }
\newcommand{\Acknowledgement}[1]{\ \\{\bf Acknowledgement:} #1}
\newcommand{\Complexity}{\vspace{0.3cm} \noindent\textbf{Time Complexity} \\}
\newcommand{\Proof}{\vspace{0.3cm} \noindent\textbf{Proof of correctness} \vspace{0.2cm} \\}
\newcommand{\Algorithm}{\textbf{Algorithm} \vspace{0.2cm}\\}
\newcommand{\EndProof} { \hfill$\square$ }
\newcommand\equ[1]{\begin{align}\begin{split} #1 \end{split} \end{align}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setlength\parindent{0pt}
\setlength{\parskip}{0.2cm}%% 
\usepackage{minted}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Make title
\title{\textmd{\bf \Class: \Title}}
\date{}
\author{\textbf{\StudentName}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle \thispagestyle{empty}
\section*{Problem 1: Always Non-negative Path}
\Algorithm
The algorithm works as following:
\begin{enumerate}
  \item For each vertex $v$, We use $P(v)$ to denote the maximum weight path from source $s$ to $v$.
  Initially we set $P(s) = 0$, and for all other nodes we set $P$ to $-\infty$. 
\item  \label{list:1} And we update $M(v)$
    in a manner similar to \textit{Bellman-Ford} algorithm, that is, we iterate over all edges $e \in E$
    for $|V|$ times, and for any edge $e = (u, v)$, if $P(u) + w(e) \geq 0$, we update value of $P(v) =
    \max(P(v), P(u) + w(e))$.
  \item Apply \textit{Depth-First-Search} (DFS) algorithm to find a positive weight cycle and for
    all vertex $v$ on the cycle, set their $P(v) = +\infty$.
  \item Repeat Step~\ref{list:1} to update value of $P$ for each vertex.
  \item There is a non-negative path from $s$ to $t$ if and only if $P(t) \geq 0$.  
\end{enumerate}


\begin{minted}[frame=lines, framesep=2mm, escapeinside=??, mathescape=true]{cpp}
function Main()
Input: Graph G = (V, E), s, t
Output: bool // whether there is a always non-negative path from s to t

P(v) = ?$-\infty$? for any ?$v \in V, v \neq s$?
P(s) = 0;

BellmanFord();
FindCycle();
BellmanFord();

return P(t) ?$\geq$? 0;
\end{minted}


\begin{minted}[frame=lines, framesep=2mm, escapeinside=??, mathescape=true]{cpp}
function BellmanFord()
for i = 1 : |V| {
  for edge (u, v)  in E {
    if P(u) + w(u, v) ?$\geq$? 0 {
      P(v) = max(P(u) + w(u, v), P(v)) 
    }
  }
}

\end{minted}

\begin{minted}[frame=lines, framesep=2mm, escapeinside=??, mathescape=true]{cpp}
function FindCycle()
S = new stack();
S.push((s, 0));

while ~S.empty() {
  (v, m) = S.pop();
  mark v as visited
  for all edges (v, u) in E {
    if P(v)
  }
}

\end{minted}

\section*{Problem 2: Pivoting vertices}
\Algorithm
Let $T = (V, E)$. For a vertex $v \in V$, let $a$ be a ancestor of $v$. Let $T_v$ be the subtree
rooted at $v$. Let $C_v = \{u | u \text{ is a child of } v\}$. Let $w(v)$ be the weight of $v$.

We use $W(v, a)$ to denote the cost of subtree $T_v$ when $v$'s closest pivot ancestor is
$a$. And $W(v, v)$ refers to the cost of subtree $T_v$ when $v$ is a pivot.   
We have the following:
\begin{enumerate}
  \item $W(v, v) = w(v) + \sum_{u \in C_v} \min(W(u, v), W(u, u))$. 
  \item $W(v, a) = w(v) - w(a) + \sum_{u \in C_v} \min( W(u, u), W(u, a))$, where $a$ is an ancestor of
    $v$.
\end{enumerate}

For base case, if $v$ is a leaf node, we have $W(v, v) = w(v)$, and $W(v, a) = w(v) - w(a)$. We
could go from leaf node and go to upper level and calculate the value of $W(v, a)$ for each
descendent-ancestor pair $v$ and $a$. 

Finally we return $W(r, r)$ where $r$ is the root node, as the minimum total cost.

\Proof
Following we prove the correctness of the induction relationship. 

\textbf{Claim 1:}
$W(v, v) = w(v) + \sum_{u \in C_v} \min(W(u, v), W(u, u))$. 

\textbf{Proof:}
If $v$ is a pivot vertex, obviously for any $u \in C_v$, if $u$ is a pivot vertex,
then the cost of subtree $T_u$ would be $W(u, u)$. If $u$ is a regular vertex, the cost of subtree
would be $W(u, v)$ because now $v$ is the closest pivot ancestor of $u$. So we have 
$W(v, v) = w(v) + \sum_{u \in C_v} \min(W(u, v), W(u, u))$. 

\textbf{Claim 2:}
 $W(v, a) = w(v) - w(a) + \sum_{u \in C_v} \min( W(u, u), W(u, a))$, where $a$ is the closest ancestor of
 $v$.

\textbf{Proof:}
In this case, obviously $v$ is not a pivot vertex, otherwise it turns into the case of $W(v, v)$.
Then the cost of $v$ would be $w(v) - w(a)$. And for any $u \in C_v$, if $u$ is a regular vertex,
the cost of subtree $T_u$ would be $W(u, a)$ since $a$ is the closest ancestor of $u$ now. And if 
$u$ is a pivot vertex, the cost of subtree $T_u$ would be $W(u, u)$. To minimize the cost, obviously we have  
$W(v, a) = w(v) - w(a) + \sum_{u \in C_v} \min( W(u, u), W(u, a))$.

\textbf{Claim 3:}

\end{document}






