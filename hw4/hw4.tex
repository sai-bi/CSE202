\documentclass{article}
\usepackage{amsmath,amsfonts,amsthm,amssymb}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{extramarks}
\usepackage{chngpage}
\usepackage{soul,color}
\usepackage{graphicx,float,wrapfig}
\usepackage{clrscode}
\usepackage{mathrsfs}
\newcommand{\Class}{CSE 202}
% \newcommand{\ClassInstructor}{Russell Impagliazzo}

% Homework Specific Information. Change it to your own
\newcommand{\Title}{Homework 3}
\newcommand{\StudentName}{Sai Bi}
\newcommand{\StudentClass}{}
\newcommand{\StudentNumber}{}

% In case you need to adjust margins:
\topmargin=-0.45in      %
\evensidemargin=0in     %
\oddsidemargin=0in      %
\textwidth=6.5in        %
\textheight=9.0in       %
\headsep=0.25in         %

% Setup the header and footer
\pagestyle{fancy}                                                       %
\lhead{\Title}  %
\rhead{\firstxmark}                                                     %
\lfoot{\lastxmark}                                                      %
\cfoot{}                                                                %
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}}                          %
\renewcommand\headrulewidth{0.4pt}                                      %
\renewcommand\footrulewidth{0.4pt}                                      %

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Some tools
\newcommand{\enterProblemHeader}[1]{\nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak%
    \nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak}%
\newcommand{\exitProblemHeader}[1]{\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak%
    \nobreak\extramarks{#1}{}\nobreak}%

\providecommand{\myceil}[1]{\left \lceil #1 \right \rceil }
\newcommand{\homeworkProblemName}{}%
\newcounter{homeworkProblemCounter}%
\newenvironment{homeworkProblem}[1][Problem \arabic{homeworkProblemCounter}]%
{\stepcounter{homeworkProblemCounter}%
    \renewcommand{\homeworkProblemName}{#1}%
    \section*{\homeworkProblemName}%
    \enterProblemHeader{\homeworkProblemName}}%
{\exitProblemHeader{\homeworkProblemName}}%

\newcommand{\homeworkSectionName}{}%
\newlength{\homeworkSectionLabelLength}{}%
\newenvironment{homeworkSection}[1]%
{% We put this space here to make sure we're not connected to the above.
    
    \renewcommand{\homeworkSectionName}{#1}%
    \settowidth{\homeworkSectionLabelLength}{\homeworkSectionName}%
    \addtolength{\homeworkSectionLabelLength}{0.25in}%
    \changetext{}{-\homeworkSectionLabelLength}{}{}{}%
    \subsection*{\homeworkSectionName}%
    \enterProblemHeader{\homeworkProblemName\ [\homeworkSectionName]}}%
{\enterProblemHeader{\homeworkProblemName}%
    
    % We put the blank space above in order to make sure this margin
    % change doesn't happen too soon.
    \changetext{}{+\homeworkSectionLabelLength}{}{}{}}%

\newcommand{\Answer}{\ \\\textbf{Answer:} }
\newcommand{\Acknowledgement}[1]{\ \\{\bf Acknowledgement:} #1}
\newcommand{\Complexity}{\vspace{0.3cm} \noindent\textbf{Time Complexity} \\}
\newcommand{\Proof}{\vspace{0.3cm} \noindent\textbf{Proof} \\}
\newcommand{\Algorithm}{\textbf{Algorithm} \\}
\newcommand{\EndProof} { \hfill$\square$ }
\newcommand\equ[1]{\begin{align}\begin{split} #1 \end{split} \end{align}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setlength\parindent{0pt}
\setlength{\parskip}{0.2cm}%% 
\usepackage{minted}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Make title
\title{\textmd{\bf \Class: \Title}}
\date{}
\author{\textbf{\StudentName}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle \thispagestyle{empty}
\section*{Problem 1: Job scheduling}
\Algorithm
We solve this problem by network flow. For each job $j$, we create a node $v_j$. 
For each processor $i$, we add a node $g_i$.
For each time unit $t_p$ during which at least one of the processor is available, we add a node $u_p$. 
Also we add a source node $s$ and a sink node $t$. 
We add edges and set their capacities as following:
\begin{enumerate}
  \item We add a directed edge between source node $s$ and node $v_j$, and the capacity is set to
    $\ell_j$.
  \item We add a directed edge between processor node $g_i$ and sink node $s$, and the capacity is
    set to $|t_i' - t_i|$.

  \item For each node $v_j$ and $u_p$, if $a_j \leq t_p$ and $d_j > t_p$, we add an edge between $v_j$
    and $u_p$ with a capacity of $1$. In this way, we can guarantee that the job cannot be assigned
    to a processor before it arrives and after the deadline passes. Also by setting capacity to $1$
    we guarantee that a job can only be set to one processor at a time unit.  
  \item For each node $u_p$ and $g_i$, if $t_i \leq t_p < t_i'$, we add an edge between $u_p$ and
    $g_i$, and the capacity of the edge is set to $1$. 
\end{enumerate}

Given above formulation, we can find the maximum flow of the network with \textit{Ford-Fulkerson}
method. If the capacity of the maximum
flow is equal to the sum of lengths of all jobs $\sum_{j} \ell_j$, then we know that the jobs can
all be completed. Otherwise, the jobs cannot be completed. 

To determine a proper scheduling when the
jobs can all be completed, suppose there is an edge with capacity $1$ between $v_j$ and $u_p$, and
there is also an edge between $u_p$ and $g_i$ with capacity $1$,  
we know at time $t_p$ that job $v_j$ can be assigned to processor $g_i$. Afterwards we delete these
two edges and determine scheduling in similar ways for remaining jobs and time units.

\Proof
First we prove that an integral flow through the graph produces a valid scheduling. We have the
following:
\begin{enumerate}
  \item The edge between source node $s$ and the node corresponding to job $v_j$ has the capacity equal
    to the length of the job, the flow through the job node won't exceed the length of the job. 
  \item We only add edge between job $v_j$ and the time unit $t_p$ where $a_j \leq t_p$ and $d_j > t_p$, so the
    job can only be assigned to a time unit that is after its arrival time and before its deadline.
    Also since we only add edge between $u_p$ and $g_i$ when processor $i$ is available at time $u_p$,
    which makes sure that a job can only be assigned to a processor at a time when the processor is
    available. By setting capacity of edge between $v_j$ and $u_p$ and edge between $u_p$ and $g_i$
    to $1$, we guarantee that a job can only be assign to a processor at a time unit. 
  \item By setting the capacity of edge between $g_i$ and $t$ to the length of interval where the
    processor is available, we guarantee that the scheduling will not exceed the available interval
    of processors.
\end{enumerate}
Given above proofs, we know that all constraints in the problems are met. So the flow produced
must be a valid scheduling.  

Suppose that $m$ is the size of an integral flow through the graph, then the total number of time
units used to do all jobs is also $m$. To finish all the jobs, the total number of time units needed
would be $T = \sum_{j}\ell_j$. Obviously $m$ cannot be larger than $T$ since the sum of capacity
of edges from source $s$ to $v_j$ is $T$. If $m < T$, it means that not all jobs have been finished.       
If $m = T$, it means that the time used to finish job $v_j$ must be equal to $\ell_j$, that is, all
jobs are finished.

In conclusion, we have proved that the proposed algorithm is correct.

\Complexity

\section*{Problem 2: Graph cohesiveness}
\subsection*{Part 1}
\Algorithm
We construct a new graph $G^*$ as following:
\begin{enumerate}
  \item For each vertex $v_i$ in $G$, we also add a corresponding vertex $v_i$ to $G^*$.
  \item For each edge $e_{ij}$ in $G$, we add a vertex $v_{ij}$ to $G^*$.  
  \item We add a source node $s$ and a sink node $t$ to $G^*$.
  \item Add edges from source node $s$ to all nodes $v_{ij}$, and set the capacity of
    these edges to $1$.
  \item Add edges from all nodes $v_i$ to sink node $t$, and set the capacity of these edges to
    $\alpha$.
  \item Add edges from node $v_{ij}$ to node $v_i$ and $v_j$, and set the capacity of these edges
   to $+\infty$.   
\end{enumerate}
Given graph $G^*$, suppose that the capacity of its minium cut is $T$, then there exists a
set with cohesiveness $\alpha$ if and only $T < |E|$, where $|E|$ is the number of edges in $G$. 

\Proof
Let $(A, B)$ be a minimum cut in graph $G^*$, let $S$ be a set of vertices $v_i$ that belong to $A$,
that is $S = \{v_i | v_i \in A \}$. We have the following claims.

\textbf{Claim 1:} If $v_{ij}\in A$, then $v_i \in A, v_j \in A$.

Proof: If $v_i \notin A$, then $v_i \in B$. Since the edge between $v_{ij}$ and $v_i$ have a
capacity of $+\infty$, therefore we know that the capacity of cut $(A, B)$ would be $+\infty$, which
is obviously not a minimum cut. Therefore $v_i$ must be in $A$. Similarly we can prove that $v_j$
must also belong to $A$.   

\textbf{Claim 2:} If $v_i \in A, v_j \in A$, then $v_{ij} \in A$.

Proof: Suppose $v_{ij} \notin A$, then we know $v_{ij} \in B$. We know that $v_ij$ only have edges
to $s$, $v_i$ and $v_j$, and they all belong to $A$, so $v_{ij}$ cannot belong to $B$. That is,
$v_{ij}$ must belong to $A$. 

\textbf{Claim 3:} Let $C(A, B)$ be the capacity of the minimum cut $(A,B)$, then $C(A, B) = |E| -
e(S) + \alpha|S|$, where $|E|$ the number of edges is $G$. 

Proof: Given $S = \{v_i | v_i \in A \}$, we know the number of nodes $v_{ij}$ satisfying $v_{ij} \in A$ is
$e(S)$. And the number of nodes $v_{ij}$ satisfying  $v_{ij}\in B$ is $|E| - e(S)$, and for each
of the node in this kind, there is an edge from source $s$ to it, and the capacity they contribute
is $|E| - e(S)$. 

Also we know that $A$ also have outgoing edges to $B$ starting from $v_i$ where $v_i \in A$. 
The number of edges are $|S|$, and each edge has a capacity of $\alpha$, so
the capacity contributed by these edges is $\alpha|S|$. 

In summary, the capacity of the minimum cut $C(A, B)$ is $|E| - e(S) + \alpha |S|$.

\textbf{Claim 4:} 
There is a set $S$ with cohesiveness at least $\alpha$ if and only if $C(A, B) \leq |E|$.

Proof: If $C(A, B) \leq |E|$, then we have
\begin{align}
    |E| - e(S) & + \alpha |S|  \leq |E| \\
    \alpha & \leq \frac{e(S)}{|S|} 
\end{align}
So we have a set S satisfying with cohesiveness at least $\alpha$.

Conversely, if we have a set $S$ with cohesiveness at least $\alpha$, we can construct a cut as
following:
\begin{align}
  A & = \{s\} \cup S \cup \{v_{ij}  | v_i \in S, v_j \in S \} \\
  B & = \{v | v \in G^*, v \notin A\}
\end{align}
It is easy to know that the capacity of cut $(A, B)$ is $|E| - e(S) + \alpha |S|$. Given
$\frac{e(S)}{S} \geq \alpha$, we have $C(A, B) \leq |E|$. So the capacity of the minimum cut must
also be smaller than or equal to $|E|$.

Given above claims, we have proved the correctness of the proposed algorithm.

\Complexity
The time used to construct $G^*$ is $O(|V||E|)$. And to find the minimum cut in $G^*$, we can
apply \textit{Edmonds-Karp} method, which has a time complexity of $O(|V||E|^2)$. Hence the time
complexity of the proposed algorithm is $O(|V|^5)$.

\subsection*{Part 2}
\Algorithm
Given the algorithm in Part 1, we can enumerate all possible values of $\frac{e(S)}{S}$. And for
all possible cohesiveness values, we sort them in ascending order. And then we find the maximum
possible cohesiveness value $\beta$ such that there is a set $S$ with cohesiveness value at least 
$\beta$. Then the maximum cohesiveness in $G$ would be $\beta$. The corresponding set would be the
$S$ we construct on $G^*$ in Part 1.   

\Proof
The correctness of the proposed algorithm is obvious since we have enumerated all possible
cohesiveness values
and finding the maximum cohesiveness value among them.

\Complexity
The number of all possible cohesiveness values is $O(|V|^3)$. And to sort them, the time complexity
is $O(|V|^3 \log |V|)$. And to find the maximum possible cohesiveness value $\beta$ in a sorted array, the
time complexity is $O(|V||E|^2 \log |V|^3 )$. Therefore, the time complexity of the proposed
algorithm is $O(|V|^5 \log |V|)$.

\section*{Problem 3: Number puzzle}

\section*{Problem 4: Database projections}

\section*{Problem 5: Maximum likelihood points of failure}

\end{document}

