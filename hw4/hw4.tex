\documentclass{article}
\usepackage{amsmath,amsfonts,amsthm,amssymb}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{extramarks}
\usepackage{chngpage}
\usepackage{soul,color}
\usepackage{graphicx,float,wrapfig}
\usepackage{clrscode}
\usepackage{mathrsfs}
\newcommand{\Class}{CSE 202}
% \newcommand{\ClassInstructor}{Russell Impagliazzo}

% Homework Specific Information. Change it to your own
\newcommand{\Title}{Homework 3}
\newcommand{\StudentName}{Sai Bi}
\newcommand{\StudentClass}{}
\newcommand{\StudentNumber}{}

% In case you need to adjust margins:
\topmargin=-0.45in      %
\evensidemargin=0in     %
\oddsidemargin=0in      %
\textwidth=6.5in        %
\textheight=9.0in       %
\headsep=0.25in         %

% Setup the header and footer
\pagestyle{fancy}                                                       %
\lhead{\Title}  %
\rhead{\firstxmark}                                                     %
\lfoot{\lastxmark}                                                      %
\cfoot{}                                                                %
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}}                          %
\renewcommand\headrulewidth{0.4pt}                                      %
\renewcommand\footrulewidth{0.4pt}                                      %

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Some tools
\newcommand{\enterProblemHeader}[1]{\nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak%
    \nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak}%
\newcommand{\exitProblemHeader}[1]{\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak%
    \nobreak\extramarks{#1}{}\nobreak}%

\providecommand{\myceil}[1]{\left \lceil #1 \right \rceil }
\newcommand{\homeworkProblemName}{}%
\newcounter{homeworkProblemCounter}%
\newenvironment{homeworkProblem}[1][Problem \arabic{homeworkProblemCounter}]%
{\stepcounter{homeworkProblemCounter}%
    \renewcommand{\homeworkProblemName}{#1}%
    \section*{\homeworkProblemName}%
    \enterProblemHeader{\homeworkProblemName}}%
{\exitProblemHeader{\homeworkProblemName}}%

\newcommand{\homeworkSectionName}{}%
\newlength{\homeworkSectionLabelLength}{}%
\newenvironment{homeworkSection}[1]%
{% We put this space here to make sure we're not connected to the above.
    
    \renewcommand{\homeworkSectionName}{#1}%
    \settowidth{\homeworkSectionLabelLength}{\homeworkSectionName}%
    \addtolength{\homeworkSectionLabelLength}{0.25in}%
    \changetext{}{-\homeworkSectionLabelLength}{}{}{}%
    \subsection*{\homeworkSectionName}%
    \enterProblemHeader{\homeworkProblemName\ [\homeworkSectionName]}}%
{\enterProblemHeader{\homeworkProblemName}%
    
    % We put the blank space above in order to make sure this margin
    % change doesn't happen too soon.
    \changetext{}{+\homeworkSectionLabelLength}{}{}{}}%

\newcommand{\Answer}{\ \\\textbf{Answer:} }
\newcommand{\Acknowledgement}[1]{\ \\{\bf Acknowledgement:} #1}
\newcommand{\Complexity}{\vspace{0.3cm} \noindent\textbf{Time Complexity} \\}
\newcommand{\Proof}{\vspace{0.3cm} \noindent\textbf{Proof} \\}
\newcommand{\Algorithm}{\textbf{Algorithm} \\}
\newcommand{\EndProof} { \hfill$\square$ }
\newcommand\equ[1]{\begin{align}\begin{split} #1 \end{split} \end{align}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setlength\parindent{0pt}
\setlength{\parskip}{0.2cm}%% 
\usepackage{minted}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Make title
\title{\textmd{\bf \Class: \Title}}
\date{}
\author{\textbf{\StudentName}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle \thispagestyle{empty}
\section*{Problem 1: Job scheduling}
\Algorithm
We solve this problem by network flow. For each job $j$, we create a node $v_j$. 
For each processor $i$, we add a node $g_i$.
For each time unit $t_p$ during which at least one of the processor is available, we add a node $u_p$. 
Also we add a source node $s$ and a sink node $t$. 
We add edges and set their capacities as following:
\begin{enumerate}
  \item We add a directed edge between source node $s$ and node $v_j$, and the capacity is set to
    $\ell_j$.
  \item We add a directed edge between processor node $g_i$ and sink node $s$, and the capacity is
    set to $|t_i' - t_i|$.

  \item For each node $v_j$ and $u_p$, if $a_j \leq t_p$ and $d_j > t_p$, we add an edge between $v_j$
    and $u_p$ with a capacity of $1$. In this way, we can guarantee that the job cannot be assigned
    to a processor before it arrives and after the deadline passes. Also by setting capacity to $1$
    we guarantee that a job can only be set to one processor at a time unit.  
  \item For each node $u_p$ and $g_i$, if $t_i \leq t_p < t_i'$, we add an edge between $u_p$ and
    $g_i$, and the capacity of the edge is set to $1$. 
\end{enumerate}

Given above formulation, we can find the maximum flow of the network with \textit{Ford-Fulkerson}
method. If the capacity of the maximum
flow is equal to the sum of lengths of all jobs $\sum_{j} \ell_j$, then we know that the jobs can
all be completed. Otherwise, the jobs cannot be completed. 

To determine a proper scheduling when the
jobs can all be completed, suppose there is an edge with capacity $1$ between $v_j$ and $u_p$, and
there is also an edge between $u_p$ and $g_i$ with capacity $1$,  
we know at time $t_p$ that job $v_j$ can be assigned to processor $g_i$. Afterwards we delete these
two edges and determine scheduling in similar ways for remaining jobs and time units.

\Proof
First we prove that an integral flow through the graph produces a valid scheduling. We have the
following:
\begin{enumerate}
  \item The edge between source node $s$ and the node corresponding to job $v_j$ has the capacity equal
    to the length of the job, the flow through the job node won't exceed the length of the job. 
  \item We only add edge between job $v_j$ and the time unit $t_p$ where $a_j \leq t_p$ and $d_j > t_p$, so the
    job can only be assigned to a time unit that is after its arrival time and before its deadline.
    Also since we only add edge between $u_p$ and $g_i$ when processor $i$ is available at time $u_p$,
    which makes sure that a job can only be assigned to a processor at a time when the processor is
    available. By setting capacity of edge between $v_j$ and $u_p$ and edge between $u_p$ and $g_i$
    to $1$, we guarantee that a job can only be assign to a processor at a time unit. 
  \item By setting the capacity of edge between $g_i$ and $t$ to the length of interval where the
    processor is available, we guarantee that the scheduling will not exceed the available interval
    of processors.
\end{enumerate}
Given above proofs, we know that all constraints in the problems are met. So the flow produced
must be a valid scheduling.  

Suppose that $m$ is the size of an integral flow through the graph, then the total number of time
units used to do all jobs is also $m$. To finish all the jobs, the total number of time units needed
would be $T = \sum_{j}\ell_j$. Obviously $m$ cannot be larger than $T$ since the sum of capacity
of edges from source $s$ to $v_j$ is $T$. If $m < T$, it means that not all jobs have been finished.       
If $m = T$, it means that the time used to finish job $v_j$ must be equal to $\ell_j$, that is, all
jobs are finished.

In conclusion, we have proved that the proposed algorithm is correct.

\Complexity

\section*{Problem 2: Graph cohesiveness}
\subsection*{Part 1}
\Algorithm
We construct a new graph $G^*$ as following:
\begin{enumerate}
  \item For each vertex $v_i$ in $G$, we also add a corresponding vertex $v_i$ to $G^*$.
  \item For each edge $e_{ij}$ in $G$, we add a vertex $v_{ij}$ to $G^*$.  
  \item We add a source node $s$ and a sink node $t$ to $G^*$.
  \item Add edges from source node $s$ to all nodes $v_{ij}$, and set the capacity of
    these edges to $1$.
  \item Add edges from all nodes $v_i$ to sink node $t$, and set the capacity of these edges to
    $\alpha$.
  \item Add edges from node $v_{ij}$ to node $v_i$ and $v_j$, and set the capacity of these edges
   to $+\infty$.   
\end{enumerate}
Given graph $G^*$, suppose that the capacity of its minium cut is $T$, then there exists a
set with cohesiveness $\alpha$ if and only $T < |E|$, where $|E|$ is the number of edges in $G$. 

\Proof
Let $(A, B)$ be a minimum cut in graph $G^*$, let $S$ be a set of vertices $v_i$ that belong to $A$,
that is $S = \{v_i | v_i \in A \}$. We have the following claims.

\textbf{Claim 1:} If $v_{ij}\in A$, then $v_i \in A, v_j \in A$.

Proof: If $v_i \notin A$, then $v_i \in B$. Since the edge between $v_{ij}$ and $v_i$ have a
capacity of $+\infty$, therefore we know that the capacity of cut $(A, B)$ would be $+\infty$, which
is obviously not a minimum cut. Therefore $v_i$ must be in $A$. Similarly we can prove that $v_j$
must also belong to $A$.   

\textbf{Claim 2:} If $v_i \in A, v_j \in A$, then $v_{ij} \in A$.

Proof: Suppose $v_{ij} \notin A$, then we know $v_{ij} \in B$. We know that $v_ij$ only have edges
to $s$, $v_i$ and $v_j$, and they all belong to $A$, so $v_{ij}$ cannot belong to $B$. That is,
$v_{ij}$ must belong to $A$. 

\textbf{Claim 3:} Let $C(A, B)$ be the capacity of the minimum cut $(A,B)$, then $C(A, B) = |E| -
e(S) + \alpha|S|$, where $|E|$ the number of edges is $G$. 

Proof: Given $S = \{v_i | v_i \in A \}$, we know the number of nodes $v_{ij}$ satisfying $v_{ij} \in A$ is
$e(S)$. And the number of nodes $v_{ij}$ satisfying  $v_{ij}\in B$ is $|E| - e(S)$, and for each
of the node in this kind, there is an edge from source $s$ to it, and the capacity they contribute
is $|E| - e(S)$. 

Also we know that $A$ also have outgoing edges to $B$ starting from $v_i$ where $v_i \in A$. 
The number of edges are $|S|$, and each edge has a capacity of $\alpha$, so
the capacity contributed by these edges is $\alpha|S|$. 

In summary, the capacity of the minimum cut $C(A, B)$ is $|E| - e(S) + \alpha |S|$.

\textbf{Claim 4:} 
There is a set $S$ with cohesiveness at least $\alpha$ if and only if $C(A, B) \leq |E|$.

Proof: If $C(A, B) \leq |E|$, then we have
\begin{align}
    |E| - e(S) & + \alpha |S|  \leq |E| \\
    \alpha & \leq \frac{e(S)}{|S|} 
\end{align}
So we have a set S satisfying with cohesiveness at least $\alpha$.

Conversely, if we have a set $S$ with cohesiveness at least $\alpha$, we can construct a cut as
following:
\begin{align}
  A & = \{s\} \cup S \cup \{v_{ij}  | v_i \in S, v_j \in S \} \\
  B & = \{v | v \in G^*, v \notin A\}
\end{align}
It is easy to know that the capacity of cut $(A, B)$ is $|E| - e(S) + \alpha |S|$. Given
$\frac{e(S)}{S} \geq \alpha$, we have $C(A, B) \leq |E|$. So the capacity of the minimum cut must
also be smaller than or equal to $|E|$.

Given above claims, we have proved the correctness of the proposed algorithm.

\Complexity
The time used to construct $G^*$ is $O(|V||E|)$. And to find the minimum cut in $G^*$, we can
apply \textit{Edmonds-Karp} method, which has a time complexity of $O(|V||E|^2)$. Hence the time
complexity of the proposed algorithm is $O(|V|^5)$.

\subsection*{Part 2}
\Algorithm
Given the algorithm in Part 1, we can enumerate all possible values of $\frac{e(S)}{S}$. And for
all possible cohesiveness values, we sort them in ascending order. And then we find the maximum
possible cohesiveness value $\beta$ such that there is a set $S$ with cohesiveness value at least 
$\beta$. Then the maximum cohesiveness in $G$ would be $\beta$. The corresponding set would be the
$S$ we construct on $G^*$ in Part 1.   

\Proof
The correctness of the proposed algorithm is obvious since we have enumerated all possible
cohesiveness values
and finding the maximum cohesiveness value among them.

\Complexity
The number of all possible cohesiveness values is $O(|V|^3)$. And to sort them, the time complexity
is $O(|V|^3 \log |V|)$. And to find the maximum possible cohesiveness value $\beta$ in a sorted array, the
time complexity is $O(|V||E|^2 \log |V|^3 )$. Therefore, the time complexity of the proposed
algorithm is $O(|V|^5 \log |V|)$.

\section*{Problem 3: Number puzzle}
\Algorithm
First, if any of $r_i$  is smaller than $n$, or any of $c_i$ is smaller than $n$, obviously no such
matrix exists.

If $r_i \leq n$ and $c_i \leq n$ for all $1 \leq i \leq n$, we construct a graph $G$ as following:
\begin{enumerate}
  \item For each $r_i$, we add a node $v_i$.
  \item For each $c_i$, we add a node $u_i$.
  \item Add a source node $s$.
  \item Add a sink node $t$.
  \item Add an edge from $s$ to $v_i$, and set the capacity to $r_i - n$.
  \item Add an edge from $u_i$ to $t$, and set the capacity to $c_i - n$.
  \item For each pair of $v_i$ and $u_j$, we add an edge from $v_i$ to $u_j$, and set the capacity to
    $M-1$. 
\end{enumerate}

With graph $G$, we find the maximum flow of it. Assume the capacity of the maximum flow is $T$, then
the required matrix exists if and only following conditions are met:
\begin{align}
  T = \sum_{i=1}^{n} (r_i - n) = \sum_{i=1}^{n}(c_i - n)
\end{align}

If the matrix exists, suppose in the maximum flow the flow from $v_i$ to $u_j$ is $f_{ij}$, then we can reconstruct the
matrix by setting $a_{ij} = f_{ij} + 1$.


\Proof
\textbf{Claim 1:} If such a matrix exists, we must have $ T = \sum_{i=1}^{n} (r_i - n) =
\sum_{i=1}^{n}(c_i - n)$.

Proof: If such a matrix exists, obviously we have 
\begin{align}
  \sum_{i=1}^{n}c_i &= \sum_{i=1}^{n}r_i \\
  \sum_{i=1}^{n}(c_i -n) &= \sum_{i=1}^{n}(r_i - n)  
\end{align}

We just need to prove the capacity of maximum flow $T$ is equal to $ \sum_{i=1}^{n}(r_i -n)$.
We can construct a flow as following: for edge from $s$ to $v_i$, we set the flow as $r_i - n$.     
For edge from $u_i$ to $t$, we set the flow as $c_i - n$. And for edge between $v_i$ and $u_j$, we
set the flow as $a_{ij} - 1$. In this way, we can easily check that it satisfies the constraints of
the network flow. Also this is a maximum flow since the capacity of the flow is $\sum_{i=1}^{n}(r_i
- n)$, which is the maximum flow going out of source. Hence Claim 1 is proved.

\textbf{Claim 2:} If $T = \sum_{i=1}^{n} (r_i - n) = \sum_{i=1}^{n}(c_i - n)$, the required
matrix must exist.

If $T = \sum_{i=1}^{n} (r_i - n) = \sum_{i=1}^{n}(c_i -n)$, the flow into $v_i$ must be equal to
$r_i - n$, and the flow going out of $u_i$ must be equal to $c_i - n$. 
Let $a_{ij} = f{ij} + 1$, where $f_{ij}$ is the flow through edge between $v_i$ and $u_j$. Then we
have $a_{ij} \geq 1$, and $a_{ij} \leq M-1 + 1 \leq M$. Since the flow into $v_i$ is $r_i - n$, we
have
\begin{align}
  r_i - n &= \sum_{j=1}^{n}f_{ij} = \sum_{j=1}^{n}(a_{ij} - 1) \\
  r_i &= \sum_{j=1}^{n}a_{ij} 
\end{align}
Similarly since the flow going out of $u_j$ is $c_j - n$, we have 
\begin{align}
  c_j - n &= \sum_{i=1}^{n}f_{ij} = \sum_{i=1}^{n}(a_{ij} - 1) \\
  c_j &= \sum_{i=1}^{n}a_{ij} 
\end{align}
Therefore the matrix we construct satisfies all constraints. Hence Claim is proved.

In conclusion, we have proved the correctness of the proposed algorithm.

\Complexity
The time used to construct the graph $G$ is $O(n^2)$. And to find the maximum flow in the graph, we
could apply \textit{Edmonds-Karp} algorithm, and the time complexity is $O(|V||E|^2)$, that is
$O(n^5)$. Therefore the time complexity of the proposed algorithm is $O(n^5)$.

\section*{Problem 4: Database projections}

\section*{Problem 5: Maximum likelihood points of failure}

\end{document}

